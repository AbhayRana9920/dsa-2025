| **Concept**                        | **Explanation**                                             | **Java Syntax / Example**                                            | **DSA Use Case**                            |
| ---------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------- |
| **Definition**                     | HashSet stores **unique elements**; no duplicates, no order | `HashSet<Integer> set = new HashSet<>();`                            | Storing unique items, removing duplicates   |
| **Add elements**                   | Add new element to set                                      | `set.add(10);`                                                       | Insert unique elements                      |
| **Remove element**                 | Remove specific element                                     | `set.remove(10);`                                                    | Delete element                              |
| **Contains**                       | Check if element exists                                     | `set.contains(20);`                                                  | Check presence                              |
| **isEmpty()**                      | Check if set is empty                                       | `set.isEmpty();`                                                     | Condition checks                            |
| **size()**                         | Number of elements                                          | `set.size();`                                                        | Looping / capacity checks                   |
| **Iteration**                      | Loop through elements                                       | `for(int x : set)`                                                   | Traversal                                   |
| **Clear**                          | Remove all elements                                         | `set.clear();`                                                       | Reset set                                   |
| **AddAll / removeAll / retainAll** | Set operations with another set                             | `set1.addAll(set2);`                                                 | Union, difference, intersection             |
| **Convert to List**                | For ordering or sorting                                     | `ArrayList<Integer> list = new ArrayList<>(set);`                    | Sorting or indexed access                   |
| **Frequency count**                | Count occurrences in original collection                    | `HashMap<Integer,Integer>` with loop                                 | Count duplicates if input was array         |
| **Null element**                   | HashSet allows **one null element**                         | `set.add(null);`                                                     | Edge case                                   |
| **Sorting**                        | HashSet is unordered â†’ convert to List or TreeSet           | `List<Integer> list = new ArrayList<>(set); Collections.sort(list);` | Sorted output                               |
| **retainAll() / intersection**     | Keep only elements present in both sets                     | `set1.retainAll(set2);`                                              | Intersection of two sets                    |
| **removeIf()**                     | Remove elements conditionally                               | `set.removeIf(x -> x % 2 == 0);`                                     | Remove unwanted elements                    |
| **clone()**                        | Create a shallow copy of HashSet                            | `HashSet<Integer> copy = (HashSet<Integer>) set.clone();`            | Backup / copy set                           |
| **toArray()**                      | Convert set to array                                        | `Integer[] arr = set.toArray(new Integer[0]);`                       | Indexed access, algorithms requiring arrays |
| **stream() / filter()**            | Process elements with Java Streams                          | `set.stream().filter(x -> x > 10).collect(Collectors.toSet());`      | Advanced filtering or mapping               |
| **TreeSet conversion**             | Convert HashSet to TreeSet for sorted elements              | `TreeSet<Integer> tree = new TreeSet<>(set);`                        | Sorted set operations                       |
| **Union without addAll**           | Manual union using loop                                     | `for(int x : set2) set1.add(x);`                                     | Understanding set operations manually       |
| **Intersection without retainAll** | Manual intersection using contains                          | `for(int x : set1) if(set2.contains(x)) result.add(x);`              | For algorithmic understanding               |
| **Difference without removeAll**   | Manual difference                                           | `for(int x : set2) set1.remove(x);`                                  | Subtract elements from another set          |
| **DSA common use case**            | Removing duplicates from array                              | `HashSet<Integer> set = new HashSet<>(Arrays.asList(arr));`          | Deduplicate array in O(n)                   |
| **Edge case: multiple nulls**      | Only one null is stored                                     | `set.add(null); set.add(null);`                                      | Test edge conditions                        |
| **Frequency map using set**        | Count unique occurrences after processing array             | `for(int x : set) freq.put(x, freq.getOrDefault(x,0)+1);`            | Counting unique elements                    |
| **Intersection of multiple sets**  | Keep elements present in all sets                           | `sets.get(0).retainAll(sets.get(1)); ...`                            | Multiset intersection problem               |
